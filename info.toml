[[exercises]]
name = "variables1"
path = "exercises/variables/variables1/main.go"
mode = "compile"
hint = """
Variables must have names."""

[[exercises]]
name = "variables2"
path = "exercises/variables/variables2/main.go"
mode = "compile"
hint = """
It is missing a symbol used to declare and initialize variables."""

[[exercises]]
name = "variables3"
path = "exercises/variables/variables3/main.go"
mode = "compile"
hint = """
Could it be missing the variable type?."""

[[exercises]]
name = "variables4"
path = "exercises/variables/variables4/main.go"
mode = "compile"
hint = """
Variables can be redeclared in new blocks, but it is missing something. What is it?."""

[[exercises]]
name = "variables5"
path = "exercises/variables/variables5/main.go"
mode = "compile"
hint = """
Constants need initialization."""

[[exercises]]
name = "variables6"
path = "exercises/variables/variables6/main.go"
mode = "compile"
hint = """
Constants can't be changed."""

[[exercises]]
name = "functions1"
path = "exercises/functions/functions1/main.go"
mode = "compile"
hint = """
The main function is calling another function that it expects to exist.
It expects a function named `call_me` to exist and receive no arguments."""

[[exercises]]
name = "functions2"
path = "exercises/functions/functions2/main.go"
mode = "compile"
hint = """
Function parameters need to have their types explicitly declared."""

[[exercises]]
name = "functions3"
path = "exercises/functions/functions3/main.go"
mode = "compile"
hint = """
When a function expect arguments, you must pass values to them."""

[[exercises]]
name = "functions4"
path = "exercises/functions/functions4/main.go"
mode = "compile"
hint = """
Functions that return values must have return types declared in the function signature."""

[[exercises]]
name = "if1"
path = "exercises/if/if1/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "if2"
path = "exercises/if/if2/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "switch1"
path = "exercises/switch/switch1/main.go"
mode = "compile"
hint = """
Switch flow is missing a variable to evaluate the statement."""

[[exercises]]
name = "switch2"
path = "exercises/switch/switch2/main.go"
mode = "compile"
hint = """
Switch without a condition is possible, but that case statement needs a boolean evaluation."""

[[exercises]]
name = "switch3"
path = "exercises/switch/switch3/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "primitive_types1"
path = "exercises/primitive_types/primitive_types1/main.go"
mode = "compile"
hint = "No hints this time"

[[exercises]]
name = "primitive_types2"
path = "exercises/primitive_types/primitive_types2/main.go"
mode = "compile"
hint = "No hints this time"

[[exercises]]
name = "primitive_types3"
path = "exercises/primitive_types/primitive_types3/main.go"
mode = "compile"
hint = "'%s' is used to format strings"

[[exercises]]
name = "primitive_types4"
path = "exercises/primitive_types/primitive_types4/main.go"
mode = "compile"
hint = """
byte can hold from 0 to 255. Could it store a character?"""

[[exercises]]
name = "primitive_types5"
path = "exercises/primitive_types/primitive_types5/main.go"
mode = "compile"
hint = """
These names seem misleading, no? But they are close to be correct.
Check this documentation to understand the variety of
numeric data types: https://go.dev/ref/spec#Numeric_types"""

[[exercises]]
name = "arrays1"
path = "exercises/arrays/arrays1/main.go"
mode = "compile"
hint = """
Arrays are zero-based indexing."""

[[exercises]]
name = "arrays2"
path = "exercises/arrays/arrays2/main.go"
mode = "compile"
hint = """
Unlike languages like Python or Ruby, go does not let you have arrays with mixed data types."""

[[exercises]]
name = "slices1"
path = "exercises/slices/slices1/main.go"
mode = "compile"
hint = """
Slices can be created with the make function and they must have a type."""

[[exercises]]
name = "slices2"
path = "exercises/slices/slices2/main.go"
mode = "compile"
hint = """
Slices can be created from arrays and you can slice it with a range, with the [low:high] syntax."""

[[exercises]]
name = "slices3"
path = "exercises/slices/slices3/main.go"
mode = "compile"
hint = """
Append is used to add elements to an existing slice.
Add some elements and read the output.

If you are still confuse about the append function, don't worry, check out
the spec: https://go.dev/ref/spec#Appending_and_copying_slices"""

[[exercises]]
name = "slices4"
path = "exercises/slices/slices4/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "maps1"
path = "exercises/maps/maps1/main.go"
mode = "compile"
hint = """
Maps have types, for the key and the values.

To make it compile you need to define types.

Indexing is similar to setting values.

Check the spec for more info: https://go.dev/ref/spec#Map_types"""

[[exercises]]
name = "maps2"
path = "exercises/maps/maps2/main.go"
mode = "compile"
hint = """
Very similar to maps1, but this time you can initialize a new map
in the same line with a different syntax.
"""

[[exercises]]
name = "maps3"
path = "exercises/maps/maps3/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "range1"
path = "exercises/range/range1/main.go"
mode = "compile"
hint = """
You can use the range keyword to iterate over collections. Arrays, slices and maps are iterable
data types."""

[[exercises]]
name = "range2"
path = "exercises/range/range2/main.go"
mode = "compile"
hint = """
Just like slices and array, you can use the range keyword to iterate over maps values.
One slightly difference between iterating over arrays and slices is that with maps we iterate
over keys and their values."""

[[exercises]]
name = "range3"
path = "exercises/range/range3/main_test.go"
mode = "test"
hint = "No hints this time"

[[exercises]]
name = "structs1"
path = "exercises/structs/structs1/main.go"
mode = "compile"
hint = """
Structs are created using the 'type structName struct {}' syntax.
Fields can be declared inside the brackets. They must have their types
declared along their names.
"""

[[exercises]]
name = "structs2"
path = "exercises/structs/structs2/main.go"
mode = "compile"
hint = """
Embedding is achieved using just the struct name.

After embedding a struct, we are able to access the fields through the base struct, without having to
specify the full path to the field. But you can do if you want.
"""

[[exercises]]
name = "anonymous-functions1"
path = "exercises/anonymous-functions/anonymous-functions1/main.go"
mode = "compile"
hint = """
The function needs a string to print
"""

[[exercises]]
name = "anonymous-functions2"
path = "exercises/anonymous-functions/anonymous-functions2/main.go"
mode = "compile"
hint = """
Maybe you should call the function with a param
"""

[[exercises]]
name = "anonymous-functions3"
path = "exercises/anonymous-functions/anonymous-functions3/main.go"
mode = "compile"
hint = """
1 - updateStatus() function should return an orderStatus index like orderStatus[index]
2 - Maybe you should call anonymous_func once more time
"""